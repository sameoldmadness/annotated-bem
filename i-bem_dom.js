// Хранилище данных о live-подписках. Подробности — чуть ниже.
var liveClassEventStorage = {};

// Объявление класса. Важно помнить, что он наследует от 'i-bem'
BEM.decl('i-bem__dom', null, {
    // `liveBindTo` — рекомендуемый способ подписки на DOM-события 
    // вложенных в блок элементов и блоков.
    // 
    // Интерфейс заимствует у live-подписки на события в jQuery,
    // что делает его использование интуитивно понятным:
    // 
    //   $('.block').on('click', 'link', function (event) {
    //     console.log('clicked!');
    //   });
    //   
    //   var block = $('.block').bem('block');
    //   block.on(block.elem('link'), 'click', function (event) {
    //     console.log('clicked!');
    //   });
    //   
    // Забавно, но в самом методе ничего серьёзного не происходит.
    liveBindTo : function(to, event, callback) {
        // Строим селектор на основе переданного контекста и имени блока
        // Например, `block__link`.
        var className = buildClass(this._name, to);

        // И делегируем основную работу приватному методу `_liveClassBind`/
        return this._liveClassBind(className, event, callback);
    },

    // В этом методе происходит непосредственно подписка на DOM-события,
    // поэтому к нему стоит отнестись повнимательнее.
    // 
    // Напомню, к этому моменту мы вооружены `className` — селектором DOM-элемента,
    // на котором нужно слушать события, `event` — названием DOM-события, а также
    // `callback` — обработчиком, который будет вызван при наступлении события.
    _liveClassBind : function(className, event, callback) {
        // Проверяем, подписывались ли мы ранее на это событие.
        if (!liveClassEventStorage[event]) {
            // Если нет, инициализируем пустое хранилище для нашего события.
            liveClassEventStorage[event] = {};
            // Вот так сюрприз! Обработчик события добавляется сразу на весь документ!
            // Забавный момент в том, что отписка от события не предусмотрена.
            // 
            // Таким образом, подписавшись и отписавшись на, скажем, событие `click`,
            // будьте готовы к тому, что `i-bem__dom` будет обрабатывать
            // _все_ клики на странице
            $(document).on(event, this._liveClassTrigger.bind(this));
        }

        // Обработчик события активирован, теперь можно проверить,
        // подписан ли на это событие элемент с селектором `className`. 
        if (!liveClassEventStorage[event][className]) {
            // Если подписки нет, создадим для него хранилище с парой полей.
            liveClassEventStorage[event][className] = {
                // Тут будут лежать идентификаторы коллбэков — они пригодятся для отписки.
                uniqIds : {},
                // А тут — сами функции.
                fns : []
            };
        }

        // Теперь наше хранилище инициализировано,
        // положим его в локальную переменную для удобства.
        var storage = liveClassEventStorage[event][className];

        // Присваиваем коллбэку уникальный идентификатор.
        // 
        // Метод `identify` работает достаточно бесхитростно: при первом вызове он
        // инкрементирует значение глобального счётчика и кладёт это значение
        // в свойство идентифицируемого объекта. При последующих вызовах идентификатор
        // будет взят из этого поля.
        var uniqId = $.identify(callback);

        // Проверка на то, что данный коллбэк уже был указан в качестве обработчика события
        if(!(uniqId in storage.uniqIds)) {
            // Если коллбэк используется впервые для этого события, кладём его в хранилище.
            storage.fns.push({
                // Указываем идентификатор.
                uniqId : uniqId,
                // И сам коллбэк, подготовленный специальным образом: в объект `event` кладём
                // DOM-element, при необходимости инициализируем блок (если он ленивый) и 
                // вызываем коллбек, передавая блок в качестве контекста.
                fn : this._buildLiveEventFn(callback)
            });

            // Ещё раз записываем в хранилище идентификатор коллбэка для быстрого доступа.
            storage.uniqIds[uniqId] = storage.fns.length - 1;
        }

        return this;
    },

    // Этот метод вызывается при срабатывании события определённого типа на DOM-элементе document.
    // 
    // Обязательным условием для вызова этого метода является наличие хотя бы одной live-подписки
    // на событие, причём не обязательно активной:
    // 
    //   block.on(block.elem('link'), 'click', onLinkClick);
    //   block.off(block.elem('link'), 'click');
    //   
    // После выполнения вышеуказанного примера метод `_liveClassTrigger` будет вызван при любом клике на странице.
    _liveClassTrigger : function(event) {
        var storage = liveClassEventStorage[e.type];

        // Проверяем, есть ли подписка на событие указанного типа.
        if(storage) {
            // DOM-элемент, на котором сработало событие.
            var node = event.target;
            // Селекторы, для которых есть подписки на событие.
            var classNames = Object.keys(storage);

            // Начинаем обход подписок.
            // 
            // Цикл выполняется до тех пор, пока есть необработанные подписки,
            // с каждой итерацией поднимаясь на один уровень DOM-дерева.
            do {
                // Строка с классами DOM-элемента текущей итерации.
                var nodeClassName = ' ' + node.className + ' ';
                var i = 0;

                // Обходим подписки, пытаясь применить их к DOM-элементу текущей итерации.
                while(className = classNames[i++]) {
                    // Как можно было заметить ранее, строка классов DOM-элемента обрамлялась
                    // с обеих сторон пробелами. Искомая строка — селектор подписки — тоже обрамлён
                    // пробелами, что позволяет отсеять частичные совпадения строк при поиске вхождения:
                    // 
                    //   node.className == 'foo bar baz';
                    //   className1 = 'foo';
                    //   className2 = 'fo';
                    //   
                    //   nodeClassName = ' ' + node.className + ' '; 
                    //   /* ' foo bar baz ' */
                    //   
                    //   nodeClassName.indexOf(' ' + className1 + ' ') > -1) 
                    //   /* ' foo bar baz '.indexOf(' foo ') -> true */
                    //   
                    //   nodeClassName.indexOf(' ' + className2 + ' ') > -1) 
                    //   /* ' foo bar baz '.indexOf(' fo ') -> false */
                    //   
                    if(nodeClassName.indexOf(' ' + className + ' ') > -1) {
                        // Если мы попали сюда, значит на DOM-элементе определён искомый блок.
                        var j = 0;
                        // Все обработчики события
                        var fns = storage[className].fns;
                        var fn;
                        // Флаг, по которому прекращается дальнейшая обработка события.                        
                        var stopPropagationAndPreventDefault = false;

                        // В этом цикле обходятся все обработчики события для селектора `className`.
                        while(fn = fns[j++]) {
                            // Вызываем обёртку над коллбэком.
                            // 
                            // При этом будет вызван коллбэк с проинициализированным 
                            // блоком в качестве контекста. 
                            if(fn.fn.call($(node), event) === false) {
                                // Если коллбэк возвращает `false`, дальнейшая обработка события будет прекращена.
                                stopPropagationAndPreventDefault = true;
                            }
                        }

                        if (stopPropagationAndPreventDefault) {
                            // Причём прекращена она будет как на нативном уровне (всплытие события прекратится).
                            e.preventDefault();
                        }

                        if(stopPropagationAndPreventDefault || e.isPropagationStopped()) {
                            // Так и на уровне live-подписки.
                            return;
                        }

                        // Блок считается обработанным и больше в процессе не участвует.
                        classNames.splice(--i, 1);
                    }
                } 
            } while(classNames.length && (node = node.parentNode));
        }
    },

    // Метод, оборачивающий обработчик события
    _buildLiveEventFn : function(callback) {
        // Запомним имя блока, оно пригодится для его ленивой инициализации.
        var blockName = this._name;
        // Запомним селектор — опять же, для ленивой инициализации.
        var className = this.buildSelector();
       
        return function(event) {
            event.data = event.data || {};
            // Кладём в объект события DOM-element, на котором сработало событие.
            event.data.domElem = $(this);

            // Находим ближайший внешний к источнику события элемент,
            // на который навешен наш блок (на самом деле, одноимённый). 
            var $domElem = event.data.domElem.closest(className);       
            // Инициализируем BEM-блок, если он ещё не проинициализирован.
            var block = initBlock(blockName, $domElem, true);

            // Вызываем коллбэк, указав в качестве контекста наш блок.
            return callback.apply(block, arguments);
        };
    }
});

// Для дальнейшего исследования:
// 
// * как происходит отписка?
// * зачем указывать порядок коллбэка в хранилище?
// * зачем указывать идентификатор в storage.fns?
// * можно ли создать подписку, инициирующую бесконечный цикл? 